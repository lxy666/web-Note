# es6知识点总结
## let变量和const变量
### let变量的特点
1. 声明的变量仅在块级作用域有效
2. 不存在变量提升
3. 暂时性死区
4. 不允许重复声明

块级作用域：外层作用域无法读取内层作用域中的变量。
在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，成为‘’暂时性死区‘’。

### 块级作用域
##### 为什么使用块级作用域
* 第一种场景，内层变量可能会覆盖外层变量
* 第二种场景，用来计数的循环泄露为全局变量

### ES6块级作用域
#### let实际上为 JavaScript 新增了块级作用域。
```javascript
function f1() {
let n = 5;
if (true) {
let n = 10;
}
console.log(n); // 5
}
```
上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是10。

#### ES6 允许块级作用域的任意嵌套。
```javascript
{{{{{let insane = 'Hello World'}}}}};
```
上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。

```javascript
{{{{
{let insane = 'Hello World'}
console.log(insane); // 报错
}}}};
```
#### 内层作用域可以定义外层作用域的同名变量。
```javascript
{{{{
let insane = 'Hello World';
{let insane = 'Hello World'}
}}}};
```
#### 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。
```javascript
// IIFE 写法
(function () {
var tmp = ...;
...
}());

// 块级作用域写法
{
let tmp = ...;
...
}
```
## const命令
### const变量的特点
1. const声明一个只读的常量。一旦声明，常量的值就不能改变。(实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动)
2. const一旦声明变量，就必须立即初始化，不能留到以后赋值。
3. 只在声明所在的块级作用域内有效。
4. 存在暂时性死区。
5. 不可重复声明。

## ES6 声明变量的六种方法
ES5只有两种声明变量的方法：``var``命令和``function``命令。ES6添加了``let``和``const``命令，还有``import`` 命令和``class``命令。

## 顶层对象的属性
>顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。这也带来了问题，比如：
1. 无法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）。
2. 程序员很容易不知不觉地就创建了全局变量（比如打字出错）。
3. 顶层对象的属性是到处可以读写的，这非常不利于模块化编程。
4. window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。

ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。






